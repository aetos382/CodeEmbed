<#@ template debug="true" hostspecific="true" language="C#" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>

<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="MultipleOutputHelper.ttinclude" #>

<#@ output extension=".cs" #>

<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingtemplate="true" #>

<#
    var manager = Manager.Create(this.Host, this.GenerationEnvironment);
    string sourceFile = this.Host.ResolvePath("GitHubModels.xml");
    string schemaFile = this.Host.ResolvePath("GitHubModels.xsd");

    var ns = (XNamespace)"http://schemas.aerie.jp/codeembed/github-models-v3";

    var settings = new XmlReaderSettings();
    settings.Schemas.Add(ns.NamespaceName, schemaFile);

	settings.ValidationType = ValidationType.Schema;
    settings.ValidationFlags =
		XmlSchemaValidationFlags.AllowXmlAttributes |
		XmlSchemaValidationFlags.ProcessIdentityConstraints |
        XmlSchemaValidationFlags.ProcessSchemaLocation |
        XmlSchemaValidationFlags.ReportValidationWarnings;

	var typeNameSpecialChars = new []{ '<', '>', ',', '[', ']' };

    using (var streamReader = new StreamReader(sourceFile))
	using (var xmlReader = XmlReader.Create(streamReader, settings))
    {
        var document = XDocument.Load(xmlReader);

        string codeNamespace = (string)document.Element(ns + "Models").Attribute("codeElement") ?? "CodeEmbed.GitHubClient";

        var modelDefs =
			document.Descendants(ns + "Model").ToDictionary(x => x.Attribute("name").Value, x => x);

        foreach (var modelDef in modelDefs.Values)
        {
            string modelName = modelDef.Attribute("name").Value;

			var parentElements = new List<XElement>();
            string parentModel = (string)modelDef.Attribute("inherits");

            while (parentModel != null)
            {
                var parentElement = modelDefs[parentModel];
				parentElements.Add(parentElement);

				parentModel = (string)parentElement.Attribute("inherits");
            }

            bool hasRequiredMember = false;

            var memberDefs = modelDef.Descendants(ns + "Member");
            foreach (var memberDef in memberDefs)
            {
				string memberType = memberDef.Attribute("type").Value;
				if (memberType.IndexOfAny(typeNameSpecialChars) != -1)
                {
					var modelType = memberDef.Element("ModelType");
					if (modelType == null)
					{
						var memberTypes = memberType.Split(typeNameSpecialChars, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim());

						foreach (var type in memberTypes)
						{
							if (modelDefs.ContainsKey(type))
							{
								int index = memberType.IndexOf(type);
								int length = type.Length;

								modelType = 
									new XElement(
										ns + "ModelType",
										new XAttribute("position", index),
										new XAttribute("length", length));

								memberDef.Add(modelType);

								break;
							}
						}
					}
                }

                bool required = (bool?)memberDef.Attribute("required") ?? false;
                if (required)
                {
                    hasRequiredMember = true;
                }
            }

            string interfaceDef = this.GenerateModel("ModelInterface.tt", codeNamespace, modelDef, parentElements);
			manager.StartNewFile(string.Format("I{0}.Generated.cs", modelName));
			this.Write(interfaceDef);
			manager.EndBlock();

            if (hasRequiredMember)
            {
				string contractDef = this.GenerateModel("ModelContract.tt", codeNamespace, modelDef, parentElements);
				manager.StartNewFile(string.Format("{0}Contracts.Generated.cs", modelName));
				this.Write(contractDef);
				manager.EndBlock();
            }

            string classDef = this.GenerateModel("ModelClass.tt", codeNamespace, modelDef, parentElements);
			manager.StartNewFile(string.Format("{0}.Generated.cs", modelName));
			this.Write(classDef);
			manager.EndBlock();

            string serializableClassDef = this.GenerateModel("SerializableClass.tt", codeNamespace, modelDef, parentElements);
			manager.StartNewFile(string.Format("Serializable{0}.Generated.cs", modelName));
			this.Write(serializableClassDef);
			manager.EndBlock();
        }
    }

	manager.Process(true);
#>

<#+
    private string GenerateModel(
		string templateFile,
		string codeNamespace,
		XElement modelDefinition,
		IEnumerable<XElement> parentModelDefinitions)
    {
        string includeContent, location;

        templateFile = this.Host.ResolvePath(templateFile);

        bool loaded = this.Host.LoadIncludeText(templateFile, out includeContent, out location);
        if (!loaded)
        {
            this.Error(string.Format("Can't load {0}.", templateFile));
            return null;
        }

        var sessionHost = (ITextTemplatingSessionHost)this.Host;

        var session = sessionHost.CreateSession();

        session["CodeNamespace"] = codeNamespace;
        session["ModelDefinitionXml"] = modelDefinition.ToString(SaveOptions.DisableFormatting);
        session["ParentModelDefinitionXmls"] =
            parentModelDefinitions.Select(x => x.ToString(SaveOptions.DisableFormatting)).ToArray();

        sessionHost.Session = session;

        var engine = new Engine();
        string result = engine.ProcessTemplate(includeContent, this.Host);

        return result;
    }
#>
