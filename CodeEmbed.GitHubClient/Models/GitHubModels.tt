<#@ template debug="true" hostspecific="true" language="C#" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>

<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="ModelDefinitionParser.ttinclude" #>
<#@ include file="MultipleOutputHelper.ttinclude" #>

<#@ output extension=".txt" #>

<#
    var manager = Manager.Create(this.Host, this.GenerationEnvironment);
    string sourceFile = this.Host.ResolvePath("GitHubModels.xml");
    string schemaFile = this.Host.ResolvePath("GitHubModels.xsd");

    var settings = new XmlReaderSettings();
    settings.Schemas.Add(SchemaNamespace.NamespaceName, schemaFile);

	settings.ValidationType = ValidationType.Schema;
    settings.ValidationFlags =
		XmlSchemaValidationFlags.AllowXmlAttributes |
		XmlSchemaValidationFlags.ProcessIdentityConstraints |
        XmlSchemaValidationFlags.ProcessSchemaLocation |
        XmlSchemaValidationFlags.ReportValidationWarnings;

    using (var streamReader = new StreamReader(sourceFile))
	using (var xmlReader = XmlReader.Create(streamReader, settings))
    {
        var document = XDocument.Load(xmlReader);

        string codeNamespace = (string)document.Element(SchemaNamespace + "Models").Attribute("codeElement") ?? "CodeEmbed.GitHubClient";

        var models = Model.ParseModels(document);

        foreach (var model in models)
        {
            bool hasRequiredMember = model.Members.Any(x => x.Required);

            string interfaceDef = this.GenerateModel("ModelInterface.tt", codeNamespace, model);
			manager.StartNewFile(string.Format("I{0}.Generated.cs", model.Name.LocalName));
			this.Write(interfaceDef);
			manager.EndBlock();

            if (hasRequiredMember)
            {
				string contractDef = this.GenerateModel("ModelContract.tt", codeNamespace, model);
				manager.StartNewFile(string.Format("{0}Contracts.Generated.cs", model.Name.LocalName));
				this.Write(contractDef);
				manager.EndBlock();
            }

            string classDef = this.GenerateModel("ModelClass.tt", codeNamespace, model);
			manager.StartNewFile(string.Format("{0}.Generated.cs", model.Name.LocalName));
			this.Write(classDef);
			manager.EndBlock();

            string serializableClassDef = this.GenerateModel("SerializableClass.tt", codeNamespace, model);
			manager.StartNewFile(string.Format("Serializable{0}.Generated.cs", model.Name.LocalName));
			this.Write(serializableClassDef);
			manager.EndBlock();
        }
    }

	manager.Process(true);
#>

<#+
    private string GenerateModel(
		string templateFile,
		string codeNamespace,
		Model model)
    {
        string includeContent, location;

        templateFile = this.Host.ResolvePath(templateFile);

        bool loaded = this.Host.LoadIncludeText(templateFile, out includeContent, out location);
        if (!loaded)
        {
            this.Error(string.Format("Can't load {0}.", templateFile));
            return null;
        }

        var sessionHost = (ITextTemplatingSessionHost)this.Host;

        var session = sessionHost.CreateSession();

		session["CodeNamespace"] = codeNamespace;
		session["ModelXml"] = model.RawXml.ToString(SaveOptions.DisableFormatting);
		session["AncestorXmls"] = model.Ancestors.Select(x => x.RawXml.ToString(SaveOptions.DisableFormatting)).ToArray();

        sessionHost.Session = session;

        var engine = new Engine();

        string result = engine.ProcessTemplate(includeContent, this.Host);
        return result;
    }
#>
