<#@ template debug="false" hostspecific="false" language="C#" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>

<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>

<#@ parameter name="Models" type="System.String" #>
<#@ parameter name="ModelName" type="System.String" #>

<#@ include file="ModelDefinitionParser.ttinclude" #>

<#
	string codeNamespace = (string)XDocument.Parse(Models).Element(SchemaNamespace + "Models").Attribute("codeElement") ?? "CodeEmbed.GitHubClient";

    var models = Model.ParseModels(Models);
	var model = models[(XName)ModelName];

    string modelName = model.Name.LocalName;

    bool hasRequiredMember = model.Members.Any(x => x.Required);
    
    var modelTypes = model.Ancestors
		.SelectMany(m => m.Members
			.Select(n => new {
				Member = n,
				Inherited = true
            }))
		.Concat(model.Members
			.Select(n => new {
				Member = n,
				Inherited = false
            }))
		.Select(m => new {
			m.Member.Name,
			Type = new[] { m.Member.Type }.Concat(m.Member.GenericArguments).SingleOrDefault(t => t.Namespace == ModelNamespace),
			m.Inherited
        })
		.Where(m => m.Type != null)
		.GroupBy(m => m.Name)
		.Select(g => new {
			TypeParameter = g.First().Type,
			Constraint = g.Last().Type,
			Inherited = g.Any(n => n.Inherited)
        })
		.Select(x => new {
			x.TypeParameter,
			x.Constraint,
			x.Inherited,
			MemberTypes = models[x.Constraint].MemberTypes
		});

    string genericParameters = string.Empty;
    if (modelTypes.Any())
    {
        var ps = modelTypes.Select(x => "out T" + x.TypeParameter.LocalName);
        genericParameters = "<" + string.Join(", ", ps) + ">";
    }

	string parentParameters = string.Empty;
	if (modelTypes.Any(t => t.Inherited))
    {
		parentParameters = "<" + string.Join(", ", modelTypes.Where(t => t.Inherited).Select(t => "T" + t.TypeParameter.LocalName)) + ">";
    }

	var members = model.Members.Where(m => !model.Ancestors.Any(a => a.Members.Any(n => n.Name == m.Name)));

    var namespaces = new List<string> {
            "System",
            "System.CodeDom.Compiler",
            "System.Diagnostics.Contracts"
        };

	var additionalNamespaces = members
		.Select(x => x.Type.NamespaceName)
		.Distinct()
		.Where(x => x.StartsWith(ClrNamespace.NamespaceName))
		.Select(x => x.Substring(ClrNamespace.NamespaceName.Length));

	namespaces.AddRange(additionalNamespaces);

    if (hasRequiredMember)
    {
        namespaces.Add(codeNamespace + ".Models.Contracts");
    }

    var orderedNamespaces = OrderNamespace(namespaces);
#>

namespace <#= codeNamespace #>.Models
{
<#
    foreach (var nss in orderedNamespaces)
    {
        foreach (var ns in nss)
        {
#>
    using <#= ns #>;
<#
        }
#>
    
<#
    }
#>
    [GeneratedCode("ModelInterface.tt", "1.0")]
<#
    if (hasRequiredMember)
    {
#>
    [ContractClass(typeof(<#= modelName #>Contract<#= GeneratedModelPostfix #>))]
<#        
    }
#>
    public partial interface I<#= modelName #><#= GeneratedModelPostfix #><#= genericParameters #>
<#
    if (model.Inherits != null)
    {
#>
        : I<#= model.Inherits.LocalName #><#= GeneratedModelPostfix #><#= parentParameters #>
<#
    }
#>
<#
    foreach (var modelType in modelTypes)
    {
#>
        where T<#= modelType.TypeParameter.LocalName #> : <#= ParseType(modelType.Constraint, modelType.MemberTypes, "I") #>
<#
    }
#>
    {
<#
    foreach (var member in members)
    {
#>
        /// <summary>Map to "<#= member.Json #>"</summary>
        <#= member.GetTypeName("T") #> <#= member.Name #> { [Pure] get; }

<#
    }
#>
    }
}
